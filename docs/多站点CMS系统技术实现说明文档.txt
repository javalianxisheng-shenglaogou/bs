================================================================================
                        多站点内容管理系统（CMS）
                          系统实现技术说明文档
================================================================================

文档版本：V1.0
编制日期：2025年10月5日
项目名称：Multi-Site CMS System
开发单位：毕业设计项目


================================================================================
                              目    录
================================================================================

一、技术架构总览
    1.1 系统整体架构设计
    1.2 技术选型概述
    1.3 系统部署架构
    1.4 技术架构优势

二、后端技术实现
    2.1 技术栈详解
    2.2 Spring Boot框架实现
    2.3 Spring Security安全框架
    2.4 Spring Data JPA数据访问
    2.5 JWT身份认证实现
    2.6 数据库技术实现
    2.7 其他核心技术

三、前端技术实现
    3.1 技术栈详解
    3.2 Vue 3框架实现
    3.3 TypeScript类型系统
    3.4 Element Plus UI组件
    3.5 Pinia状态管理
    3.6 Vue Router路由管理
    3.7 Axios HTTP客户端
    3.8 其他核心技术

四、数据库设计与实现
    4.1 数据库选型理由
    4.2 Flyway版本管理
    4.3 数据库连接池配置
    4.4 核心数据表设计

五、安全技术实现
    5.1 JWT身份认证原理
    5.2 Spring Security权限控制
    5.3 密码加密存储方案
    5.4 安全防护措施

六、核心功能技术难点分析
    6.1 多站点数据隔离
    6.2 工作流引擎设计
    6.3 权限系统细粒度控制
    6.4 文件上传和管理
    6.5 富文本编辑器集成

七、性能优化技术
    7.1 前端性能优化
    7.2 后端性能优化
    7.3 数据库性能优化

八、开发工具与环境
    8.1 开发工具选择
    8.2 构建工具配置
    8.3 开发环境要求
    8.4 版本控制管理

九、技术创新点
    9.1 前后端分离架构
    9.2 基于角色的权限控制
    9.3 可配置工作流引擎
    9.4 多站点统一管理

十、附录
    10.1 技术参考文档
    10.2 常见问题解答
    10.3 变更记录


================================================================================
                          一、技术架构总览
================================================================================

1.1 系统整体架构设计
--------------------------------------------------------------------------------
本系统采用前后端分离的架构设计，前端和后端通过RESTful API进行通信。
这种架构具有以下优势：

（1）前后端分离架构
    ┌─────────────────────────────────────────────────────────┐
    │                      前端层（Vue 3）                      │
    │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
    │  │ 用户界面  │  │ 路由管理  │  │ 状态管理  │  │ HTTP请求  │ │
    │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
    └─────────────────────────────────────────────────────────┘
                              ↕ RESTful API
    ┌─────────────────────────────────────────────────────────┐
    │                  后端层（Spring Boot）                    │
    │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
    │  │ 控制器层  │  │ 服务层    │  │ 数据访问层 │  │ 安全层    │ │
    │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
    └─────────────────────────────────────────────────────────┘
                              ↕ JDBC
    ┌─────────────────────────────────────────────────────────┐
    │                    数据层（MySQL）                        │
    │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
    │  │ 用户表    │  │ 内容表    │  │ 站点表    │  │ 权限表    │ │
    │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
    └─────────────────────────────────────────────────────────┘

（2）架构特点
    - 前端和后端独立开发、独立部署
    - 前端通过HTTP请求调用后端API
    - 后端提供RESTful风格的API接口
    - 使用JWT进行身份认证和授权
    - 数据以JSON格式进行传输

（3）架构优势
    - 开发效率高：前后端可以并行开发
    - 可维护性强：前后端代码分离，职责清晰
    - 可扩展性好：可以独立扩展前端或后端
    - 用户体验好：前端可以实现单页应用（SPA）


1.2 技术选型概述
--------------------------------------------------------------------------------
本系统的技术选型遵循以下原则：
- 成熟稳定：选择经过大量项目验证的成熟技术
- 社区活跃：选择有活跃社区支持的技术
- 易于学习：选择学习曲线平缓的技术
- 性能优秀：选择性能表现优秀的技术

（1）后端技术栈
    技术名称              版本          作用说明
    ─────────────────────────────────────────────────────
    Java                 11           开发语言
    Spring Boot          2.7.18       应用框架
    Spring Security      5.7.x        安全框架
    Spring Data JPA      2.7.x        数据访问框架
    MySQL                8.0          关系数据库
    Flyway               9.22.3       数据库版本管理
    JWT                  0.11.5       身份认证令牌
    Lombok               1.18.x       代码简化工具
    MapStruct            1.5.5        对象映射工具
    SpringDoc            1.7.0        API文档工具
    Hibernate Validator  6.2.x        参数校验框架

（2）前端技术栈
    技术名称              版本          作用说明
    ─────────────────────────────────────────────────────
    Vue                  3.5.22       前端框架
    TypeScript           5.9.3        开发语言
    Element Plus         2.11.4       UI组件库
    Pinia                3.0.3        状态管理
    Vue Router           4.5.1        路由管理
    Axios                1.12.2       HTTP客户端
    Vite                 5.4.11       构建工具
    Vue Quill            1.2.0        富文本编辑器


1.3 系统部署架构
--------------------------------------------------------------------------------
（1）开发环境部署
    - 前端：运行在Node.js开发服务器（端口3000）
    - 后端：运行在Spring Boot内置Tomcat（端口8080）
    - 数据库：MySQL 8.0（端口3306）
    - 前端通过代理访问后端API

（2）生产环境部署（推荐）
    ┌─────────────────────────────────────────────────────────┐
    │                      Nginx反向代理                        │
    │                      （端口80/443）                       │
    └─────────────────────────────────────────────────────────┘
                    ↙                              ↘
    ┌──────────────────────┐              ┌──────────────────────┐
    │   前端静态文件服务    │              │   后端API服务         │
    │   （Vue构建产物）     │              │   （Spring Boot）     │
    │   端口：80           │              │   端口：8080          │
    └──────────────────────┘              └──────────────────────┘
                                                    ↓
                                          ┌──────────────────────┐
                                          │   MySQL数据库         │
                                          │   端口：3306          │
                                          └──────────────────────┘

（3）部署说明
    - Nginx作为反向代理，处理静态文件和API请求
    - 前端构建后的静态文件部署到Nginx
    - 后端Spring Boot应用独立部署
    - MySQL数据库独立部署，可以使用主从复制提高可用性


1.4 技术架构优势
--------------------------------------------------------------------------------
（1）前后端分离的优势
    - 开发效率：前后端团队可以并行开发，互不干扰
    - 职责清晰：前端专注于用户界面，后端专注于业务逻辑
    - 技术独立：前后端可以独立选择技术栈和升级版本
    - 易于测试：前后端可以独立进行单元测试和集成测试

（2）Spring Boot的优势
    - 快速开发：提供大量开箱即用的功能
    - 约定优于配置：减少配置工作量
    - 内置服务器：无需单独部署Tomcat
    - 生态丰富：有大量的Starter和第三方库

（3）Vue 3的优势
    - 性能优秀：采用Proxy响应式系统，性能更好
    - 组合式API：代码组织更灵活，逻辑复用更方便
    - TypeScript支持：提供完整的类型支持
    - 生态成熟：有丰富的组件库和工具链

（4）MySQL的优势
    - 成熟稳定：经过多年验证，稳定性高
    - 性能优秀：查询性能和并发性能都很好
    - 社区活跃：有大量的文档和社区支持
    - 功能丰富：支持事务、索引、外键等高级功能


================================================================================
                          二、后端技术实现
================================================================================

2.1 技术栈详解
--------------------------------------------------------------------------------
后端采用Java 11和Spring Boot 2.7.18作为核心技术栈，构建RESTful风格的
API服务。

（1）Java 11
    是什么：
    - Java 11是Oracle发布的长期支持（LTS）版本
    - 提供了许多新特性，如局部变量类型推断、HTTP Client API等

    为什么选择：
    - 长期支持：Oracle承诺提供至少8年的支持
    - 性能提升：相比Java 8有显著的性能提升
    - 新特性：提供了许多实用的新特性
    - 稳定性：经过多年验证，稳定性高

    怎么实现：
    - 在pom.xml中配置Java版本为11
    - 使用Maven编译插件指定源码和目标版本为11
    - 配置示例：
      <properties>
          <java.version>11</java.version>
          <maven.compiler.source>11</maven.compiler.source>
          <maven.compiler.target>11</maven.compiler.target>
      </properties>

（2）Spring Boot 2.7.18
    是什么：
    - Spring Boot是Spring框架的快速开发脚手架
    - 提供了自动配置、内置服务器、健康检查等功能
    - 2.7.18是2.x系列的最新稳定版本

    为什么选择：
    - 快速开发：大量开箱即用的功能，减少配置工作
    - 生态丰富：有大量的Starter和第三方集成
    - 社区活跃：有活跃的社区和丰富的文档
    - 稳定可靠：经过大量项目验证，稳定性高

    怎么实现：
    - 使用Spring Boot Starter Parent作为父POM
    - 引入所需的Starter依赖（Web、JPA、Security等）
    - 使用@SpringBootApplication注解启动应用
    - 配置示例：
      <parent>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-parent</artifactId>
          <version>2.7.18</version>
      </parent>


2.2 Spring Boot框架实现
--------------------------------------------------------------------------------
Spring Boot框架是整个后端应用的基础，提供了依赖注入、自动配置、
内置服务器等核心功能。

（1）项目结构设计
    backend/
    ├── src/main/java/com/cms/
    │   ├── CmsApplication.java          # 应用启动类
    │   ├── common/                      # 公共模块
    │   │   ├── base/                    # 基础类（响应、异常等）
    │   │   ├── config/                  # 配置类
    │   │   └── util/                    # 工具类
    │   ├── security/                    # 安全模块
    │   │   ├── config/                  # 安全配置
    │   │   ├── filter/                  # 过滤器
    │   │   └── util/                    # 安全工具
    │   └── module/                      # 业务模块
    │       ├── user/                    # 用户模块
    │       ├── site/                    # 站点模块
    │       ├── content/                 # 内容模块
    │       ├── category/                # 分类模块
    │       ├── workflow/                # 工作流模块
    │       ├── file/                    # 文件模块
    │       └── log/                     # 日志模块
    └── src/main/resources/
        ├── application.yml              # 主配置文件
        ├── application-dev.yml          # 开发环境配置
        └── db/migration/                # 数据库迁移脚本

（2）分层架构设计
    Controller层（控制器层）：
    - 职责：接收HTTP请求，调用Service层处理业务，返回响应
    - 注解：@RestController、@RequestMapping
    - 示例：UserController、ContentController

    Service层（服务层）：
    - 职责：处理业务逻辑，调用Repository层访问数据
    - 注解：@Service、@Transactional
    - 示例：UserService、ContentService

    Repository层（数据访问层）：
    - 职责：访问数据库，执行CRUD操作
    - 注解：@Repository（继承JpaRepository）
    - 示例：UserRepository、ContentRepository

    Entity层（实体层）：
    - 职责：定义数据库表对应的实体类
    - 注解：@Entity、@Table、@Column
    - 示例：User、Content、Site

    DTO层（数据传输对象层）：
    - 职责：定义前后端数据传输的对象
    - 注解：无特殊注解，使用Lombok简化代码
    - 示例：UserDTO、ContentDTO

（3）自动配置机制
    Spring Boot的自动配置是其核心特性之一，通过条件注解自动配置Bean。

    示例：数据源自动配置
    - Spring Boot检测到classpath中有MySQL驱动
    - 自动配置DataSource、JdbcTemplate、EntityManagerFactory等Bean
    - 只需在application.yml中配置数据库连接信息即可

    配置示例：
    spring:
      datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/multi_site_cms
        username: root
        password: 123456

（4）内置Tomcat服务器
    Spring Boot内置了Tomcat服务器，无需单独部署。

    优势：
    - 简化部署：应用打包成jar文件即可运行
    - 快速启动：开发时可以快速启动和重启
    - 易于调试：可以直接在IDE中调试

    配置示例：
    server:
      port: 8080
      servlet:
        context-path: /api


2.3 Spring Security安全框架
--------------------------------------------------------------------------------
Spring Security是Spring生态中的安全框架，提供了认证、授权、防护等
安全功能。

（1）Spring Security核心概念
    是什么：
    - Spring Security是一个功能强大的安全框架
    - 提供认证（Authentication）和授权（Authorization）功能
    - 支持多种认证方式（表单登录、JWT、OAuth2等）

    为什么选择：
    - 功能完善：提供了完整的安全解决方案
    - 灵活可扩展：可以自定义认证和授权逻辑
    - 与Spring集成：与Spring框架无缝集成
    - 社区支持：有丰富的文档和社区支持

    怎么实现：
    - 引入spring-boot-starter-security依赖
    - 创建SecurityConfig配置类
    - 实现UserDetailsService接口加载用户信息
    - 配置HTTP安全规则和过滤器链

（2）安全配置实现
    核心配置类：SecurityConfig.java

    主要配置内容：
    a. 禁用CSRF保护
       - 原因：使用JWT进行认证，不需要CSRF保护
       - 代码：http.csrf().disable()

    b. 禁用Session
       - 原因：使用JWT进行认证，不需要Session
       - 代码：http.sessionManagement()
                   .sessionCreationPolicy(SessionCreationPolicy.STATELESS)

    c. 配置请求授权
       - 白名单：/auth/**、/test/**、/files/**等路径允许匿名访问
       - 其他请求：需要认证后才能访问
       - 代码：http.authorizeRequests()
                   .antMatchers("/auth/**").permitAll()
                   .anyRequest().authenticated()

    d. 添加JWT过滤器
       - 在UsernamePasswordAuthenticationFilter之前添加JWT过滤器
       - 用于解析和验证JWT令牌
       - 代码：http.addFilterBefore(jwtAuthenticationFilter,
                                     UsernamePasswordAuthenticationFilter.class)

（3）JWT认证过滤器实现
    核心类：JwtAuthenticationFilter.java

    工作流程：
    1. 从请求头中获取Authorization字段
    2. 提取Bearer令牌
    3. 解析JWT令牌，获取用户名
    4. 加载用户详情
    5. 验证令牌有效性
    6. 创建认证对象并设置到SecurityContext

    关键代码逻辑：
    - 从请求头获取令牌：
      String authHeader = request.getHeader("Authorization");
      if (authHeader != null && authHeader.startsWith("Bearer ")) {
          token = authHeader.substring(7);
      }

    - 验证令牌并设置认证：
      String username = jwtUtil.getUsernameFromToken(token);
      UserDetails userDetails = userDetailsService.loadUserByUsername(username);
      if (jwtUtil.validateToken(token, username)) {
          UsernamePasswordAuthenticationToken authentication =
              new UsernamePasswordAuthenticationToken(
                  userDetails, null, userDetails.getAuthorities());
          SecurityContextHolder.getContext().setAuthentication(authentication);
      }

（4）用户详情服务实现
    核心类：UserDetailsServiceImpl.java

    职责：
    - 实现UserDetailsService接口
    - 根据用户名加载用户信息
    - 将用户信息转换为Spring Security的UserDetails对象

    实现逻辑：
    1. 根据用户名查询用户实体
    2. 查询用户的角色和权限
    3. 将权限转换为GrantedAuthority集合
    4. 创建UserDetailsImpl对象返回

    权限格式：
    - 权限代码格式：模块:操作（如user:create、content:view）
    - 在@PreAuthorize注解中使用：@PreAuthorize("hasAuthority('user:create')")


2.4 Spring Data JPA数据访问
--------------------------------------------------------------------------------
Spring Data JPA是Spring提供的数据访问框架，简化了JPA的使用。

（1）Spring Data JPA核心概念
    是什么：
    - Spring Data JPA是对JPA规范的封装
    - 提供了Repository接口，简化数据访问代码
    - 支持方法名查询、JPQL查询、原生SQL查询

    为什么选择：
    - 简化开发：无需编写大量的DAO代码
    - 类型安全：使用Java类型而不是SQL字符串
    - 自动实现：Repository接口方法自动实现
    - 功能丰富：支持分页、排序、动态查询等

    怎么实现：
    - 引入spring-boot-starter-data-jpa依赖
    - 创建Entity实体类，使用JPA注解
    - 创建Repository接口，继承JpaRepository
    - 在Service层注入Repository并使用

（2）实体类设计
    使用JPA注解定义实体类和数据库表的映射关系。

    常用注解：
    @Entity              - 标识实体类
    @Table               - 指定表名
    @Id                  - 标识主键
    @GeneratedValue      - 主键生成策略
    @Column              - 指定列名和属性
    @ManyToOne           - 多对一关系
    @OneToMany           - 一对多关系
    @ManyToMany          - 多对多关系
    @JoinTable           - 指定关联表

    示例：User实体类
    @Entity
    @Table(name = "users")
    public class User {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @Column(nullable = false, unique = true, length = 50)
        private String username;

        @Column(nullable = false, length = 100)
        private String password;

        @ManyToMany(fetch = FetchType.EAGER)
        @JoinTable(
            name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id")
        )
        private Set<Role> roles;
    }

（3）Repository接口设计
    继承JpaRepository接口，自动获得CRUD方法。

    基础方法（JpaRepository提供）：
    - save(entity)           - 保存或更新实体
    - findById(id)           - 根据ID查询
    - findAll()              - 查询所有
    - deleteById(id)         - 根据ID删除
    - count()                - 统计数量
    - existsById(id)         - 判断是否存在

    自定义查询方法：
    - 方法名查询：根据方法名自动生成查询
      例如：findByUsername(String username)
           findByStatusAndSiteId(String status, Long siteId)

    - JPQL查询：使用@Query注解编写JPQL
      例如：@Query("SELECT u FROM User u WHERE u.email = ?1")
           User findByEmail(String email);

    - 原生SQL查询：使用@Query注解编写SQL
      例如：@Query(value = "SELECT * FROM users WHERE status = ?1",
                   nativeQuery = true)
           List<User> findByStatusNative(String status);

（4）分页和排序
    Spring Data JPA提供了强大的分页和排序功能。

    分页查询：
    - 方法参数使用Pageable
    - 返回类型使用Page<T>
    - 示例：
      Page<User> findAll(Pageable pageable);

      // 调用示例
      Pageable pageable = PageRequest.of(0, 10, Sort.by("createTime").descending());
      Page<User> userPage = userRepository.findAll(pageable);

    排序查询：
    - 方法参数使用Sort
    - 示例：
      List<User> findAll(Sort sort);

      // 调用示例
      Sort sort = Sort.by("username").ascending();
      List<User> users = userRepository.findAll(sort);


2.5 JWT身份认证实现
--------------------------------------------------------------------------------
JWT（JSON Web Token）是一种基于令牌的身份认证方案，适合前后端分离
的应用。

（1）JWT核心概念
    是什么：
    - JWT是一种开放标准（RFC 7519）
    - 用于在各方之间安全地传输信息
    - 由三部分组成：Header（头部）、Payload（载荷）、Signature（签名）

    为什么选择：
    - 无状态：服务器不需要存储Session
    - 跨域友好：可以在不同域之间传递
    - 性能好：不需要查询数据库验证Session
    - 易于扩展：可以在载荷中存储自定义信息

    怎么实现：
    - 引入jjwt依赖（io.jsonwebtoken:jjwt-api:0.11.5）
    - 创建JwtUtil工具类，封装JWT操作
    - 创建JwtConfig配置类，配置密钥和过期时间
    - 在登录成功后生成JWT令牌
    - 在请求时验证JWT令牌

（2）JWT工具类实现
    核心类：JwtUtil.java

    主要方法：
    a. 生成令牌
       public String generateToken(String username, Long userId) {
           Map<String, Object> claims = new HashMap<>();
           claims.put("userId", userId);
           claims.put("username", username);

           Date now = new Date();
           Date expiration = new Date(now.getTime() + jwtConfig.getExpiration());

           return Jwts.builder()
                   .setClaims(claims)
                   .setSubject(username)
                   .setIssuedAt(now)
                   .setExpiration(expiration)
                   .signWith(getSecretKey(), SignatureAlgorithm.HS256)
                   .compact();
       }

    b. 解析令牌
       public String getUsernameFromToken(String token) {
           Claims claims = Jwts.parserBuilder()
                   .setSigningKey(getSecretKey())
                   .build()
                   .parseClaimsJws(token)
                   .getBody();
           return claims.getSubject();
       }

    c. 验证令牌
       public boolean validateToken(String token, String username) {
           String tokenUsername = getUsernameFromToken(token);
           Date expiration = getExpirationDateFromToken(token);
           return tokenUsername.equals(username) &&
                  !expiration.before(new Date());
       }

（3）JWT配置
    配置类：JwtConfig.java

    配置项：
    - secret：JWT签名密钥（至少256位）
    - expiration：令牌过期时间（毫秒）
    - tokenPrefix：令牌前缀（Bearer）
    - headerName：请求头名称（Authorization）

    配置示例（application.yml）：
    jwt:
      secret: your-256-bit-secret-key-here-must-be-at-least-256-bits
      expiration: 86400000  # 24小时
      token-prefix: Bearer
      header-name: Authorization

（4）登录流程
    完整的JWT认证流程：

    1. 用户登录
       - 前端发送用户名和密码到/api/auth/login
       - 后端验证用户名和密码
       - 验证成功后生成JWT令牌
       - 返回令牌给前端

    2. 前端存储令牌
       - 将令牌存储到localStorage
       - 在后续请求中携带令牌

    3. 后端验证令牌
       - JwtAuthenticationFilter拦截请求
       - 从请求头中提取令牌
       - 验证令牌有效性
       - 设置认证信息到SecurityContext

    4. 访问受保护资源
       - Controller方法使用@PreAuthorize注解
       - Spring Security检查用户权限
       - 有权限则执行方法，无权限则返回403


2.6 数据库技术实现
--------------------------------------------------------------------------------
本系统使用MySQL 8.0作为关系数据库，使用Flyway进行数据库版本管理。

（1）MySQL 8.0
    是什么：
    - MySQL是世界上最流行的开源关系数据库
    - 8.0版本提供了许多新特性（窗口函数、CTE、JSON支持等）

    为什么选择：
    - 成熟稳定：经过多年验证，稳定性高
    - 性能优秀：查询性能和并发性能都很好
    - 功能丰富：支持事务、索引、外键、触发器等
    - 社区活跃：有大量的文档和社区支持
    - 成本低：开源免费

    怎么实现：
    - 安装MySQL 8.0数据库
    - 创建数据库：multi_site_cms
    - 配置数据源连接信息
    - 使用Flyway自动创建表结构

（2）Flyway数据库版本管理
    是什么：
    - Flyway是一个数据库版本管理工具
    - 使用SQL脚本或Java代码管理数据库变更
    - 支持版本控制、回滚、迁移等功能

    为什么选择：
    - 版本控制：数据库变更可以版本化管理
    - 自动执行：应用启动时自动执行迁移脚本
    - 团队协作：团队成员共享数据库变更
    - 环境一致：开发、测试、生产环境数据库结构一致

    怎么实现：
    - 引入flyway-core和flyway-mysql依赖
    - 在resources/db/migration目录下创建SQL脚本
    - 脚本命名规则：V版本号__描述.sql
      例如：V1.0.0__init_schema.sql
           V1.0.1__add_user_table.sql
    - 应用启动时Flyway自动执行未执行的脚本

    配置示例：
    spring:
      flyway:
        enabled: true
        baseline-on-migrate: true
        locations: classpath:db/migration
        encoding: UTF-8
        validate-on-migrate: true
        out-of-order: true

（3）HikariCP连接池
    是什么：
    - HikariCP是一个高性能的JDBC连接池
    - Spring Boot 2.x默认使用HikariCP

    为什么选择：
    - 性能优秀：号称最快的连接池
    - 稳定可靠：经过大量项目验证
    - 配置简单：提供合理的默认配置

    配置示例：
    spring:
      datasource:
        hikari:
          minimum-idle: 5              # 最小空闲连接数
          maximum-pool-size: 20        # 最大连接数
          auto-commit: true            # 自动提交
          idle-timeout: 30000          # 空闲超时时间（毫秒）
          pool-name: CmsHikariCP       # 连接池名称
          max-lifetime: 1800000        # 连接最大生命周期（毫秒）
          connection-timeout: 30000    # 连接超时时间（毫秒）


2.7 其他核心技术
--------------------------------------------------------------------------------
（1）Lombok
    是什么：
    - Lombok是一个Java库，通过注解自动生成代码
    - 可以自动生成getter、setter、toString、equals等方法

    为什么选择：
    - 减少样板代码：不需要手写getter/setter
    - 提高可读性：代码更简洁
    - 易于维护：修改字段时不需要修改方法

    常用注解：
    @Data              - 生成getter、setter、toString、equals、hashCode
    @Getter/@Setter    - 生成getter/setter方法
    @NoArgsConstructor - 生成无参构造函数
    @AllArgsConstructor- 生成全参构造函数
    @Builder           - 生成建造者模式代码
    @Slf4j             - 生成日志对象

（2）MapStruct
    是什么：
    - MapStruct是一个对象映射工具
    - 在编译时生成类型安全的映射代码

    为什么选择：
    - 类型安全：编译时检查类型
    - 性能好：生成的是普通Java代码，无反射
    - 易于使用：只需定义接口即可

    使用示例：
    @Mapper(componentModel = "spring")
    public interface UserMapper {
        UserDTO toDTO(User user);
        User toEntity(UserDTO dto);
        List<UserDTO> toDTOList(List<User> users);
    }

（3）SpringDoc（Swagger）
    是什么：
    - SpringDoc是OpenAPI 3.0规范的实现
    - 自动生成API文档和测试界面

    为什么选择：
    - 自动生成：根据代码自动生成文档
    - 在线测试：提供Swagger UI测试接口
    - 标准规范：遵循OpenAPI 3.0标准

    配置示例：
    springdoc:
      api-docs:
        enabled: true
        path: /v3/api-docs
      swagger-ui:
        enabled: true
        path: /swagger-ui.html

    访问地址：http://localhost:8080/api/swagger-ui.html

（4）Hibernate Validator
    是什么：
    - Hibernate Validator是Bean Validation规范的实现
    - 用于验证Java Bean的属性

    为什么选择：
    - 声明式验证：使用注解声明验证规则
    - 功能丰富：提供大量内置验证注解
    - 易于扩展：可以自定义验证注解

    常用注解：
    @NotNull           - 不能为null
    @NotBlank          - 不能为空字符串
    @Size              - 字符串长度或集合大小
    @Min/@Max          - 数值范围
    @Email             - 邮箱格式
    @Pattern           - 正则表达式

    使用示例：
    public class UserCreateRequest {
        @NotBlank(message = "用户名不能为空")
        @Size(min = 3, max = 50, message = "用户名长度必须在3-50之间")
        private String username;

        @NotBlank(message = "密码不能为空")
        @Size(min = 6, message = "密码长度至少为6位")
        private String password;

        @Email(message = "邮箱格式不正确")
        private String email;
    }


================================================================================
                          三、前端技术实现
================================================================================

3.1 技术栈详解
--------------------------------------------------------------------------------
前端采用Vue 3和TypeScript作为核心技术栈，构建现代化的单页应用（SPA）。

（1）Vue 3
    是什么：
    - Vue 3是渐进式JavaScript框架
    - 采用组合式API（Composition API）
    - 使用Proxy实现响应式系统

    为什么选择：
    - 性能优秀：相比Vue 2性能提升显著
    - 易于学习：学习曲线平缓，文档完善
    - 生态丰富：有大量的组件库和工具
    - TypeScript支持：提供完整的类型支持

    怎么实现：
    - 使用Vite创建Vue 3项目
    - 使用组合式API编写组件
    - 使用<script setup>语法糖简化代码

（2）TypeScript
    是什么：
    - TypeScript是JavaScript的超集
    - 添加了静态类型系统
    - 编译后生成纯JavaScript代码

    为什么选择：
    - 类型安全：编译时检查类型错误
    - IDE支持：提供更好的代码提示和重构
    - 易于维护：大型项目更易维护
    - 渐进式：可以逐步迁移JavaScript代码

    怎么实现：
    - 在项目中使用.ts和.vue文件
    - 定义接口和类型
    - 使用泛型增强类型安全


3.2 Vue 3框架实现
--------------------------------------------------------------------------------
Vue 3框架是整个前端应用的基础，提供了响应式系统、组件系统、路由等
核心功能。

（1）项目结构设计
    frontend/
    ├── src/
    │   ├── main.ts                  # 应用入口
    │   ├── App.vue                  # 根组件
    │   ├── api/                     # API接口
    │   │   ├── auth.ts              # 认证接口
    │   │   ├── user.ts              # 用户接口
    │   │   ├── content.ts           # 内容接口
    │   │   └── ...
    │   ├── components/              # 公共组件
    │   │   ├── Loading.vue          # 加载组件
    │   │   └── ...
    │   ├── layouts/                 # 布局组件
    │   │   └── MainLayout.vue       # 主布局
    │   ├── router/                  # 路由配置
    │   │   └── index.ts             # 路由定义
    │   ├── store/                   # 状态管理
    │   │   └── user.ts              # 用户状态
    │   ├── types/                   # 类型定义
    │   │   └── index.ts             # 类型声明
    │   ├── utils/                   # 工具函数
    │   │   ├── request.ts           # HTTP请求封装
    │   │   ├── errorHandler.ts     # 错误处理
    │   │   ├── apiHelper.ts         # API辅助工具
    │   │   └── debounce.ts          # 防抖节流
    │   └── views/                   # 页面组件
    │       ├── Login.vue            # 登录页
    │       ├── Dashboard.vue        # 仪表盘
    │       ├── Users.vue            # 用户管理
    │       └── ...
    └── public/                      # 静态资源

（2）组合式API（Composition API）
    Vue 3推荐使用组合式API编写组件，相比选项式API有以下优势：

    优势：
    - 更好的逻辑复用：可以提取逻辑到组合函数
    - 更好的类型推导：TypeScript支持更好
    - 更灵活的代码组织：相关逻辑可以组织在一起

    示例：使用组合式API
    <script setup lang="ts">
    import { ref, onMounted } from 'vue'
    import { useUserStore } from '@/store/user'

    // 响应式数据
    const loading = ref(false)
    const userList = ref([])

    // 使用store
    const userStore = useUserStore()

    // 方法
    const loadUsers = async () => {
      loading.value = true
      try {
        const response = await userApi.getUsers()
        userList.value = response.data
      } finally {
        loading.value = false
      }
    }

    // 生命周期钩子
    onMounted(() => {
      loadUsers()
    })
    </script>

（3）响应式系统
    Vue 3使用Proxy实现响应式系统，相比Vue 2的Object.defineProperty有
    以下优势：

    优势：
    - 可以检测属性的添加和删除
    - 可以检测数组索引和length的变化
    - 性能更好

    响应式API：
    - ref()：创建响应式引用
    - reactive()：创建响应式对象
    - computed()：创建计算属性
    - watch()：监听响应式数据变化
    - watchEffect()：自动追踪依赖并执行

    示例：
    import { ref, reactive, computed, watch } from 'vue'

    // ref：基本类型
    const count = ref(0)
    count.value++  // 访问需要.value

    // reactive：对象类型
    const state = reactive({
      name: 'John',
      age: 30
    })
    state.name = 'Jane'  // 直接访问

    // computed：计算属性
    const doubleCount = computed(() => count.value * 2)

    // watch：监听变化
    watch(count, (newValue, oldValue) => {
      console.log(`count changed from ${oldValue} to ${newValue}`)
    })

（4）组件通信
    Vue 3提供了多种组件通信方式：

    a. Props（父传子）
       父组件：
       <ChildComponent :message="parentMessage" />

       子组件：
       <script setup lang="ts">
       defineProps<{
         message: string
       }>()
       </script>

    b. Emits（子传父）
       子组件：
       <script setup lang="ts">
       const emit = defineEmits<{
         (e: 'update', value: string): void
       }>()

       const handleClick = () => {
         emit('update', 'new value')
       }
       </script>

       父组件：
       <ChildComponent @update="handleUpdate" />

    c. Provide/Inject（跨层级）
       祖先组件：
       provide('key', value)

       后代组件：
       const value = inject('key')

    d. Store（全局状态）
       使用Pinia进行全局状态管理（见3.5节）


3.3 TypeScript类型系统
--------------------------------------------------------------------------------
TypeScript为JavaScript添加了静态类型系统，提高了代码质量和开发效率。

（1）类型定义
    本系统定义了完整的类型系统，包括：

    a. 基础类型定义（types/index.ts）
       // 用户类型
       export interface User {
         id: number
         username: string
         email: string
         nickname: string
         avatarUrl?: string
         status: string
         roles: Role[]
         permissions: Permission[]
         createTime: string
         updateTime: string
       }

       // 角色类型
       export interface Role {
         id: number
         name: string
         code: string
         description?: string
       }

       // 权限类型
       export interface Permission {
         id: number
         name: string
         code: string
         module: string
         resource: string
         action: string
       }

    b. 请求类型定义
       export interface UserCreateRequest {
         username: string
         password: string
         email: string
         nickname: string
         roleIds: number[]
       }

       export interface UserUpdateRequest {
         email?: string
         nickname?: string
         roleIds?: number[]
       }

    c. 响应类型定义
       export interface ApiResponse<T> {
         code: number
         message: string
         data: T
       }

       export interface PageResponse<T> {
         content: T[]
         total: number
         page: number
         size: number
       }

（2）泛型使用
    使用泛型增强类型安全和代码复用：

    示例：API辅助函数
    export async function fetchList<T>(
      apiFunc: Function,
      params: any = {}
    ): Promise<T[]> {
      try {
        const response = await apiFunc(params)
        if (response.code === 200) {
          return response.data as T[]
        }
        return []
      } catch (error) {
        handleError(error)
        return []
      }
    }

    // 使用示例
    const users = await fetchList<User>(userApi.getUsers)
    const sites = await fetchList<Site>(siteApi.getSites)


3.4 Element Plus UI组件
--------------------------------------------------------------------------------
Element Plus是基于Vue 3的UI组件库，提供了丰富的组件。

（1）Element Plus核心概念
    是什么：
    - Element Plus是Element UI的Vue 3版本
    - 提供了60+高质量组件
    - 支持TypeScript和组合式API

    为什么选择：
    - 组件丰富：提供了大量常用组件
    - 设计统一：遵循统一的设计规范
    - 文档完善：有详细的中文文档
    - 社区活跃：有活跃的社区支持

    怎么实现：
    - 安装element-plus和@element-plus/icons-vue
    - 在main.ts中全局注册
    - 在组件中使用

（2）常用组件
    表单组件：
    - el-form：表单容器
    - el-form-item：表单项
    - el-input：输入框
    - el-select：下拉选择
    - el-date-picker：日期选择
    - el-upload：文件上传

    数据展示组件：
    - el-table：表格
    - el-pagination：分页
    - el-tree：树形控件
    - el-card：卡片
    - el-tag：标签

    反馈组件：
    - el-message：消息提示
    - el-message-box：消息弹框
    - el-notification：通知
    - el-loading：加载

    导航组件：
    - el-menu：菜单
    - el-breadcrumb：面包屑
    - el-tabs：标签页


3.5 Pinia状态管理
--------------------------------------------------------------------------------
Pinia是Vue 3官方推荐的状态管理库，替代了Vuex。

（1）Pinia核心概念
    是什么：
    - Pinia是Vue的状态管理库
    - 提供了类型安全的状态管理
    - 支持组合式API和选项式API

    为什么选择：
    - 类型安全：完整的TypeScript支持
    - 轻量简洁：API更简单，代码更少
    - 模块化：每个store都是独立的
    - DevTools支持：支持Vue DevTools调试

    怎么实现：
    - 安装pinia
    - 在main.ts中创建pinia实例
    - 定义store
    - 在组件中使用store

（2）Store定义
    使用组合式API定义store：

    示例：用户Store（store/user.ts）
    import { defineStore } from 'pinia'
    import { ref } from 'vue'

    export const useUserStore = defineStore('user', () => {
      // 状态
      const token = ref<string>(localStorage.getItem('token') || '')
      const userInfo = ref<UserInfo | null>(null)

      // Getters（计算属性）
      const isLoggedIn = computed(() => !!token.value)
      const hasPermission = (permission: string) => {
        return userInfo.value?.permissions.includes(permission) || false
      }

      // Actions（方法）
      const setToken = (newToken: string) => {
        token.value = newToken
        localStorage.setItem('token', newToken)
      }

      const login = async (loginData: LoginRequest) => {
        const response = await loginApi(loginData)
        if (response.code === 200) {
          setToken(response.data.token)
          userInfo.value = response.data
          return true
        }
        return false
      }

      const logout = () => {
        token.value = ''
        userInfo.value = null
        localStorage.removeItem('token')
      }

      return {
        token,
        userInfo,
        isLoggedIn,
        hasPermission,
        setToken,
        login,
        logout
      }
    })

（3）在组件中使用Store
    <script setup lang="ts">
    import { useUserStore } from '@/store/user'

    const userStore = useUserStore()

    // 访问状态
    console.log(userStore.token)
    console.log(userStore.userInfo)

    // 调用方法
    const handleLogin = async () => {
      const success = await userStore.login({
        username: 'admin',
        password: 'password'
      })
      if (success) {
        router.push('/dashboard')
      }
    }

    // 检查权限
    const canCreateUser = userStore.hasPermission('user:create')
    </script>


3.6 Vue Router路由管理
--------------------------------------------------------------------------------
Vue Router是Vue的官方路由管理器，用于构建单页应用。

（1）Vue Router核心概念
    是什么：
    - Vue Router是Vue的官方路由库
    - 支持嵌套路由、动态路由、路由守卫等功能

    为什么选择：
    - 官方支持：Vue官方维护
    - 功能完善：支持各种路由需求
    - 易于使用：API简单直观

    怎么实现：
    - 安装vue-router
    - 定义路由配置
    - 创建路由实例
    - 在main.ts中注册

（2）路由配置
    示例：router/index.ts
    import { createRouter, createWebHistory } from 'vue-router'

    const routes = [
      {
        path: '/login',
        name: 'Login',
        component: () => import('@/views/Login.vue'),
        meta: { title: '登录' }
      },
      {
        path: '/',
        component: () => import('@/layouts/MainLayout.vue'),
        redirect: '/dashboard',
        children: [
          {
            path: '/dashboard',
            name: 'Dashboard',
            component: () => import('@/views/Dashboard.vue'),
            meta: {
              title: '仪表盘',
              icon: 'HomeFilled',
              showInMenu: true
            }
          },
          {
            path: '/users',
            name: 'Users',
            component: () => import('@/views/Users.vue'),
            meta: {
              title: '用户管理',
              icon: 'User',
              showInMenu: true,
              permissions: ['user:view']
            }
          }
        ]
      }
    ]

    const router = createRouter({
      history: createWebHistory(),
      routes
    })

（3）路由守卫
    实现权限控制和登录验证：

    全局前置守卫：
    router.beforeEach((to, from, next) => {
      const userStore = useUserStore()

      // 白名单路径
      const whiteList = ['/login', '/register']

      if (userStore.token) {
        // 已登录
        if (to.path === '/login') {
          next('/dashboard')
        } else {
          // 检查权限
          const permissions = to.meta.permissions as string[]
          if (permissions && permissions.length > 0) {
            const hasPermission = permissions.some(p =>
              userStore.hasPermission(p)
            )
            if (hasPermission) {
              next()
            } else {
              ElMessage.error('没有权限访问该页面')
              next('/dashboard')
            }
          } else {
            next()
          }
        }
      } else {
        // 未登录
        if (whiteList.includes(to.path)) {
          next()
        } else {
          next('/login')
        }
      }
    })


3.7 Axios HTTP客户端
--------------------------------------------------------------------------------
Axios是基于Promise的HTTP客户端，用于发送HTTP请求。

（1）Axios核心概念
    是什么：
    - Axios是一个基于Promise的HTTP库
    - 支持浏览器和Node.js
    - 提供了拦截器、取消请求等功能

    为什么选择：
    - 功能强大：支持拦截器、转换器等
    - 易于使用：API简单直观
    - 浏览器兼容：支持主流浏览器
    - Promise支持：支持async/await

    怎么实现：
    - 安装axios
    - 创建axios实例
    - 配置请求拦截器和响应拦截器
    - 封装API接口

（2）Axios实例配置
    示例：utils/request.ts
    import axios from 'axios'
    import { useUserStore } from '@/store/user'
    import { ElMessage } from 'element-plus'

    // 创建axios实例
    const request = axios.create({
      baseURL: '/api',
      timeout: 10000
    })

    // 请求拦截器
    request.interceptors.request.use(
      config => {
        const userStore = useUserStore()
        if (userStore.token) {
          config.headers.Authorization = `Bearer ${userStore.token}`
        }
        return config
      },
      error => {
        return Promise.reject(error)
      }
    )

    // 响应拦截器
    request.interceptors.response.use(
      response => {
        return response.data
      },
      error => {
        if (error.response) {
          const status = error.response.status
          switch (status) {
            case 401:
              ElMessage.error('未登录或登录已过期')
              const userStore = useUserStore()
              userStore.logout()
              router.push('/login')
              break
            case 403:
              ElMessage.error('没有权限访问')
              break
            case 404:
              ElMessage.error('请求的资源不存在')
              break
            case 500:
              ElMessage.error('服务器错误')
              break
            default:
              ElMessage.error('请求失败')
          }
        }
        return Promise.reject(error)
      }
    )

    export default request

（3）API接口封装
    示例：api/user.ts
    import request from '@/utils/request'

    export const userApi = {
      // 获取用户列表
      getUsers: (params?: any) => {
        return request.get('/users', { params })
      },

      // 获取用户详情
      getUserById: (id: number) => {
        return request.get(`/users/${id}`)
      },

      // 创建用户
      createUser: (data: UserCreateRequest) => {
        return request.post('/users', data)
      },

      // 更新用户
      updateUser: (id: number, data: UserUpdateRequest) => {
        return request.put(`/users/${id}`, data)
      },

      // 删除用户
      deleteUser: (id: number) => {
        return request.delete(`/users/${id}`)
      }
    }


3.8 其他核心技术
--------------------------------------------------------------------------------
（1）Vite构建工具
    是什么：
    - Vite是新一代前端构建工具
    - 基于ES模块，开发时无需打包
    - 使用Rollup进行生产构建

    为什么选择：
    - 启动快：开发服务器秒级启动
    - 热更新快：模块级别的热更新
    - 构建快：使用Rollup优化构建
    - 配置简单：开箱即用

    配置示例：vite.config.ts
    import { defineConfig } from 'vite'
    import vue from '@vitejs/plugin-vue'
    import path from 'path'

    export default defineConfig({
      plugins: [vue()],
      resolve: {
        alias: {
          '@': path.resolve(__dirname, 'src')
        }
      },
      server: {
        port: 3000,
        proxy: {
          '/api': {
            target: 'http://localhost:8080',
            changeOrigin: true
          }
        }
      }
    })

（2）Vue Quill富文本编辑器
    是什么：
    - Vue Quill是Quill编辑器的Vue 3封装
    - 提供了富文本编辑功能

    为什么选择：
    - 功能丰富：支持文本格式、图片、链接等
    - 易于使用：Vue组件封装
    - 可定制：支持自定义工具栏

    使用示例：
    <template>
      <QuillEditor
        v-model:content="content"
        contentType="html"
        theme="snow"
        :options="editorOptions"
      />
    </template>

    <script setup lang="ts">
    import { QuillEditor } from '@vueup/vue-quill'
    import '@vueup/vue-quill/dist/vue-quill.snow.css'

    const content = ref('')
    const editorOptions = {
      modules: {
        toolbar: [
          ['bold', 'italic', 'underline'],
          [{ 'header': [1, 2, 3, false] }],
          [{ 'list': 'ordered'}, { 'list': 'bullet' }],
          ['link', 'image']
        ]
      }
    }
    </script>


================================================================================
                      四、数据库设计与实现
================================================================================

4.1 数据库选型理由
--------------------------------------------------------------------------------
本系统选择MySQL 8.0作为关系数据库，主要基于以下考虑：

（1）成熟稳定
    - MySQL是世界上最流行的开源数据库
    - 经过20多年的发展，稳定性极高
    - 被大量企业级应用使用和验证

（2）性能优秀
    - 查询性能优秀，支持高并发
    - 支持索引优化，提高查询速度
    - 支持查询缓存，减少数据库压力

（3）功能丰富
    - 支持事务（ACID特性）
    - 支持外键约束，保证数据完整性
    - 支持触发器、存储过程等高级功能
    - 支持JSON数据类型（MySQL 8.0）

（4）社区活跃
    - 有大量的文档和教程
    - 有活跃的社区支持
    - 有丰富的工具和客户端

（5）成本低
    - 开源免费
    - 运维成本低
    - 学习成本低


4.2 Flyway版本管理
--------------------------------------------------------------------------------
Flyway是数据库版本管理工具，用于管理数据库变更。

（1）Flyway工作原理
    - Flyway在数据库中创建一个flyway_schema_history表
    - 记录已执行的迁移脚本
    - 应用启动时检查未执行的脚本并执行
    - 保证数据库版本与代码版本一致

（2）迁移脚本命名规则
    格式：V版本号__描述.sql

    示例：
    V1.0.0__init_schema.sql          # 初始化数据库结构
    V1.0.1__add_user_table.sql       # 添加用户表
    V1.0.2__add_site_table.sql       # 添加站点表
    V1.1.0__add_workflow_tables.sql  # 添加工作流表
    V1.2.0__add_indexes.sql          # 添加索引
    V1.2.1__insert_test_data.sql     # 插入测试数据

（3）迁移脚本示例
    V1.0.0__init_schema.sql：

    -- 创建用户表
    CREATE TABLE users (
        id BIGINT AUTO_INCREMENT PRIMARY KEY,
        username VARCHAR(50) NOT NULL UNIQUE,
        password VARCHAR(100) NOT NULL,
        email VARCHAR(100) NOT NULL,
        nickname VARCHAR(50),
        avatar_url VARCHAR(500),
        status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
        create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                    ON UPDATE CURRENT_TIMESTAMP,
        INDEX idx_username (username),
        INDEX idx_email (email),
        INDEX idx_status (status)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

    -- 创建角色表
    CREATE TABLE roles (
        id BIGINT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(50) NOT NULL,
        code VARCHAR(50) NOT NULL UNIQUE,
        description VARCHAR(500),
        create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                    ON UPDATE CURRENT_TIMESTAMP
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


4.3 数据库连接池配置
--------------------------------------------------------------------------------
本系统使用HikariCP作为数据库连接池，这是Spring Boot 2.x的默认连接池。

（1）HikariCP优势
    - 性能优秀：号称最快的JDBC连接池
    - 稳定可靠：经过大量项目验证
    - 配置简单：提供合理的默认配置
    - 轻量级：代码量少，依赖少

（2）连接池配置参数
    minimum-idle：最小空闲连接数
    - 默认值：与maximum-pool-size相同
    - 推荐值：5
    - 说明：连接池维持的最小空闲连接数

    maximum-pool-size：最大连接数
    - 默认值：10
    - 推荐值：20
    - 说明：连接池允许的最大连接数

    connection-timeout：连接超时时间
    - 默认值：30000毫秒（30秒）
    - 说明：客户端等待连接的最大时间

    idle-timeout：空闲超时时间
    - 默认值：600000毫秒（10分钟）
    - 推荐值：30000毫秒（30秒）
    - 说明：连接空闲多久后被释放

    max-lifetime：连接最大生命周期
    - 默认值：1800000毫秒（30分钟）
    - 说明：连接在池中的最大存活时间


4.4 核心数据表设计
--------------------------------------------------------------------------------
本系统的核心数据表包括：

（1）用户相关表
    users：用户表
    - 存储用户基本信息
    - 字段：id、username、password、email、nickname、avatar_url、status

    roles：角色表
    - 存储角色信息
    - 字段：id、name、code、description

    permissions：权限表
    - 存储权限信息
    - 字段：id、name、code、module、resource、action

    user_roles：用户角色关联表
    - 多对多关系
    - 字段：user_id、role_id

    role_permissions：角色权限关联表
    - 多对多关系
    - 字段：role_id、permission_id

（2）站点相关表
    sites：站点表
    - 存储站点信息
    - 字段：id、name、domain、description、logo_url、status

    categories：分类表
    - 存储分类信息，支持树形结构
    - 字段：id、name、code、parent_id、site_id、sort_order、is_visible

（3）内容相关表
    contents：内容表
    - 存储内容信息
    - 字段：id、title、content、summary、cover_image、site_id、
            category_id、author_id、status、approval_status、publish_time

（4）工作流相关表
    workflows：工作流定义表
    - 存储工作流配置
    - 字段：id、name、code、description、nodes（JSON）、status

    workflow_instances：工作流实例表
    - 存储工作流执行实例
    - 字段：id、workflow_id、business_type、business_id、
            current_node_id、status、initiator_id

    workflow_tasks：工作流任务表
    - 存储审批任务
    - 字段：id、instance_id、node_id、assignee_id、status、
            comment、complete_time

（5）系统日志表
    system_logs：系统日志表
    - 存储系统操作日志
    - 字段：id、user_id、username、operation_type、operation_module、
            operation_content、ip_address、status、operation_time


================================================================================
                        五、安全技术实现
================================================================================

5.1 JWT身份认证原理
--------------------------------------------------------------------------------
JWT（JSON Web Token）是一种基于令牌的身份认证方案。

（1）JWT结构
    JWT由三部分组成，用点（.）分隔：

    Header.Payload.Signature

    a. Header（头部）
       包含令牌类型和签名算法
       {
         "alg": "HS256",
         "typ": "JWT"
       }

    b. Payload（载荷）
       包含声明信息（用户信息、过期时间等）
       {
         "userId": 1,
         "username": "admin",
         "iat": 1609459200,
         "exp": 1609545600
       }

    c. Signature（签名）
       使用密钥对Header和Payload进行签名
       HMACSHA256(
         base64UrlEncode(header) + "." + base64UrlEncode(payload),
         secret
       )

（2）JWT认证流程
    1. 用户登录
       - 用户提交用户名和密码
       - 后端验证用户名和密码
       - 验证成功后生成JWT令牌
       - 返回令牌给前端

    2. 前端存储令牌
       - 将令牌存储到localStorage
       - 在后续请求中携带令牌

    3. 后端验证令牌
       - 从请求头中提取令牌
       - 验证令牌签名
       - 验证令牌是否过期
       - 提取用户信息

    4. 访问受保护资源
       - 根据用户权限判断是否允许访问
       - 允许则返回资源，否则返回403

（3）JWT优势
    - 无状态：服务器不需要存储Session
    - 可扩展：可以在载荷中存储自定义信息
    - 跨域：可以在不同域之间传递
    - 性能好：不需要查询数据库验证Session

（4）JWT安全措施
    - 使用强密钥：密钥长度至少256位
    - 设置过期时间：防止令牌被长期使用
    - HTTPS传输：防止令牌被窃取
    - 刷新令牌：提供令牌刷新机制


5.2 Spring Security权限控制
--------------------------------------------------------------------------------
Spring Security提供了完整的权限控制解决方案。

（1）RBAC权限模型
    本系统采用基于角色的访问控制（RBAC）模型：

    用户（User） → 角色（Role） → 权限（Permission）

    - 用户可以拥有多个角色
    - 角色可以拥有多个权限
    - 权限定义了具体的操作

（2）权限注解
    使用@PreAuthorize注解进行权限控制：

    示例：
    @PreAuthorize("hasAuthority('user:create')")
    public ApiResponse<UserDTO> createUser(@RequestBody UserCreateRequest request) {
        // 创建用户逻辑
    }

    @PreAuthorize("hasAuthority('user:update')")
    public ApiResponse<UserDTO> updateUser(@PathVariable Long id,
                                           @RequestBody UserUpdateRequest request) {
        // 更新用户逻辑
    }

    @PreAuthorize("isAuthenticated()")
    public ApiResponse<UserDTO> getCurrentUser() {
        // 获取当前用户信息
    }

（3）权限检查流程
    1. 用户发起请求
    2. JwtAuthenticationFilter验证JWT令牌
    3. 加载用户权限信息
    4. Spring Security检查方法上的@PreAuthorize注解
    5. 判断用户是否拥有所需权限
    6. 有权限则执行方法，无权限则抛出AccessDeniedException

（4）数据权限控制
    除了功能权限，还需要控制数据权限：

    示例：用户只能操作自己创建的内容
    public ApiResponse<ContentDTO> updateContent(Long id, ContentDTO dto) {
        Long currentUserId = SecurityUtils.getCurrentUserId();
        Content content = contentRepository.findById(id)
                .orElseThrow(() -> new BusinessException("内容不存在"));

        // 检查是否是内容作者或管理员
        if (!content.getAuthorId().equals(currentUserId) &&
            !SecurityUtils.isAdmin()) {
            throw new AccessDeniedException("您只能编辑自己创建的内容");
        }

        // 更新内容逻辑
    }


5.3 密码加密存储方案
--------------------------------------------------------------------------------
本系统使用BCrypt算法加密存储用户密码。

（1）BCrypt算法
    是什么：
    - BCrypt是一种密码哈希算法
    - 基于Blowfish加密算法
    - 自动加盐，防止彩虹表攻击

    为什么选择：
    - 安全性高：计算复杂度高，难以破解
    - 自动加盐：每次加密结果不同
    - 可配置强度：可以调整计算复杂度
    - Spring Security内置：无需额外依赖

    怎么实现：
    - 在SecurityConfig中配置PasswordEncoder
    - 使用BCryptPasswordEncoder
    - 在保存用户时加密密码
    - 在登录时验证密码

（2）密码加密实现
    配置PasswordEncoder：
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    加密密码：
    public UserDTO createUser(UserCreateRequest request) {
        User user = new User();
        user.setUsername(request.getUsername());
        // 加密密码
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setEmail(request.getEmail());
        userRepository.save(user);
        return userMapper.toDTO(user);
    }

    验证密码：
    public boolean authenticate(String username, String password) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new BusinessException("用户不存在"));
        // 验证密码
        return passwordEncoder.matches(password, user.getPassword());
    }

（3）密码安全策略
    - 密码长度：至少6位
    - 密码复杂度：建议包含大小写字母、数字、特殊字符
    - 密码过期：定期提醒用户修改密码（可选）
    - 登录失败锁定：连续失败多次后锁定账户（可选）


5.4 安全防护措施
--------------------------------------------------------------------------------
（1）SQL注入防护
    措施：
    - 使用JPA和参数化查询
    - 避免拼接SQL语句
    - 使用@Query注解时使用参数绑定

    示例：
    // 安全的查询
    @Query("SELECT u FROM User u WHERE u.username = ?1")
    User findByUsername(String username);

    // 不安全的查询（避免）
    // String sql = "SELECT * FROM users WHERE username = '" + username + "'";

（2）XSS攻击防护
    措施：
    - 对用户输入进行过滤和转义
    - 富文本内容进行安全过滤
    - 设置HTTP响应头（X-XSS-Protection）

    实现：
    - 前端：使用Vue的v-html时要谨慎
    - 后端：对富文本内容进行过滤
    - 响应头：X-XSS-Protection: 1; mode=block

（3）CSRF攻击防护
    措施：
    - 使用JWT进行认证，不使用Cookie
    - 验证请求来源（Referer、Origin）
    - 使用CSRF令牌（可选）

    说明：
    - 本系统使用JWT认证，不使用Session和Cookie
    - JWT存储在localStorage，不会被CSRF攻击
    - 因此禁用了Spring Security的CSRF保护

（4）文件上传安全
    措施：
    - 限制文件类型：只允许特定类型的文件
    - 限制文件大小：防止上传超大文件
    - 文件名重命名：防止文件名注入
    - 存储路径隔离：不同类型文件存储在不同目录

    实现：
    private void validateImageFile(MultipartFile file) {
        // 检查文件是否为空
        if (file.isEmpty()) {
            throw new BusinessException("文件不能为空");
        }

        // 检查文件大小
        if (file.getSize() > MAX_IMAGE_SIZE) {
            throw new BusinessException("图片大小不能超过5MB");
        }

        // 检查文件类型
        String contentType = file.getContentType();
        if (!ALLOWED_IMAGE_TYPES.contains(contentType)) {
            throw new BusinessException("只支持JPG、PNG、GIF、WEBP格式的图片");
        }
    }


================================================================================
                    六、核心功能技术难点分析
================================================================================

6.1 多站点数据隔离
--------------------------------------------------------------------------------
（1）技术难点
    - 如何确保不同站点的数据相互隔离
    - 如何防止用户访问其他站点的数据
    - 如何在查询时自动过滤站点数据

（2）解决方案
    a. 数据库设计
       - 在需要隔离的表中添加site_id字段
       - 建立外键关联，确保数据完整性
       - 创建复合索引（site_id, other_fields）

    b. 查询过滤
       - 在Repository层添加site_id参数
       - 使用JPA的方法名查询自动过滤
       - 使用@Query注解添加site_id条件

    示例：
    public interface ContentRepository extends JpaRepository<Content, Long> {
        // 方法名查询，自动添加site_id条件
        Page<Content> findBySiteId(Long siteId, Pageable pageable);

        // JPQL查询，手动添加site_id条件
        @Query("SELECT c FROM Content c WHERE c.siteId = ?1 AND c.status = ?2")
        List<Content> findBySiteIdAndStatus(Long siteId, String status);
    }

    c. Service层封装
       - 在Service层方法中强制传入site_id
       - 在创建数据时自动设置site_id
       - 在更新数据时验证site_id

    示例：
    public ContentDTO createContent(Long siteId, ContentDTO dto) {
        Content content = contentMapper.toEntity(dto);
        content.setSiteId(siteId);  // 强制设置site_id
        content.setAuthorId(SecurityUtils.getCurrentUserId());
        contentRepository.save(content);
        return contentMapper.toDTO(content);
    }


6.2 工作流引擎设计
--------------------------------------------------------------------------------
（1）技术难点
    - 如何设计灵活可配置的工作流
    - 如何处理工作流的流转逻辑
    - 如何避免循环依赖问题

（2）解决方案
    a. 工作流定义
       - 使用JSON存储工作流节点配置
       - 节点类型：START（开始）、APPROVAL（审批）、END（结束）
       - 节点属性：id、name、type、assignees（审批人列表）

    示例：
    {
      "nodes": [
        {
          "id": "start",
          "name": "开始",
          "nodeType": "START"
        },
        {
          "id": "approval1",
          "name": "初审",
          "nodeType": "APPROVAL",
          "assignees": [1, 2, 3]
        },
        {
          "id": "approval2",
          "name": "终审",
          "nodeType": "APPROVAL",
          "assignees": [4, 5]
        },
        {
          "id": "end",
          "name": "结束",
          "nodeType": "END"
        }
      ]
    }

    b. 工作流实例
       - 启动工作流时创建实例
       - 记录当前节点ID
       - 记录实例状态（PENDING、IN_PROGRESS、COMPLETED、REJECTED）

    c. 任务创建
       - 到达审批节点时创建任务
       - 为每个审批人创建一个任务
       - 任务状态：PENDING、APPROVED、REJECTED

    d. 流程流转
       - 任务完成后检查是否所有任务都完成
       - 如果都完成，流转到下一个节点
       - 如果有拒绝，结束工作流

    e. 循环依赖解决
       - 使用ApplicationContext延迟获取Bean
       - 避免在构造函数中注入相互依赖的Bean

    示例：
    @Service
    public class WorkflowInstanceService {
        @Autowired
        private ApplicationContext applicationContext;

        private WorkflowTaskService getTaskService() {
            return applicationContext.getBean(WorkflowTaskService.class);
        }
    }


6.3 权限系统细粒度控制
--------------------------------------------------------------------------------
（1）技术难点
    - 如何实现细粒度的权限控制
    - 如何动态加载用户权限
    - 如何在前端根据权限显示/隐藏功能

（2）解决方案
    a. 权限定义
       - 权限格式：模块:操作（如user:create、content:view）
       - 权限存储在permissions表
       - 通过role_permissions表关联角色和权限

    b. 权限加载
       - 用户登录时加载所有权限
       - 将权限转换为GrantedAuthority
       - 存储在SecurityContext中

    示例：
    public UserDetails loadUserByUsername(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("用户不存在"));

        // 加载用户权限
        Set<String> permissions = new HashSet<>();
        for (Role role : user.getRoles()) {
            for (Permission permission : role.getPermissions()) {
                permissions.add(permission.getCode());
            }
        }

        // 转换为GrantedAuthority
        List<GrantedAuthority> authorities = permissions.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());

        return new UserDetailsImpl(user, authorities);
    }

    c. 后端权限控制
       - 使用@PreAuthorize注解
       - 在Service层添加数据权限检查

    d. 前端权限控制
       - 在路由meta中定义所需权限
       - 在路由守卫中检查权限
       - 在组件中根据权限显示/隐藏按钮

    示例：
    // 路由定义
    {
      path: '/users',
      meta: {
        permissions: ['user:view']
      }
    }

    // 路由守卫
    router.beforeEach((to, from, next) => {
      const permissions = to.meta.permissions
      if (permissions && permissions.length > 0) {
        const hasPermission = permissions.some(p =>
          userStore.hasPermission(p)
        )
        if (!hasPermission) {
          ElMessage.error('没有权限访问')
          next('/dashboard')
          return
        }
      }
      next()
    })

    // 组件中使用
    <el-button
      v-if="userStore.hasPermission('user:create')"
      @click="handleCreate">
      创建用户
    </el-button>


6.4 文件上传和管理
--------------------------------------------------------------------------------
（1）技术难点
    - 如何安全地处理文件上传
    - 如何生成唯一的文件名
    - 如何组织文件存储结构

（2）解决方案
    a. 文件验证
       - 验证文件类型（MIME类型）
       - 验证文件大小
       - 验证文件扩展名

    b. 文件存储
       - 按日期组织目录结构（avatars/2025/10/05/）
       - 使用UUID生成唯一文件名
       - 保留原始文件扩展名

    示例：
    private FileUploadResponse saveFile(MultipartFile file, String relativePath) {
        try {
            // 生成唯一文件名
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename.substring(
                originalFilename.lastIndexOf("."));
            String filename = UUID.randomUUID().toString() + extension;

            // 创建目录
            Path directory = Paths.get(uploadDir, relativePath);
            Files.createDirectories(directory);

            // 保存文件
            Path filePath = directory.resolve(filename);
            Files.copy(file.getInputStream(), filePath);

            // 生成访问URL
            String fileUrl = "/files/" + relativePath + "/" + filename;

            return new FileUploadResponse(filename, fileUrl);
        } catch (IOException e) {
            throw new BusinessException("文件保存失败");
        }
    }

    c. 文件访问
       - 配置静态资源映射
       - 通过URL直接访问文件

    示例：
    @Configuration
    public class WebMvcConfig implements WebMvcConfigurer {
        @Value("${file.upload-dir}")
        private String uploadDir;

        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
            registry.addResourceHandler("/files/**")
                    .addResourceLocations("file:" + uploadDir + "/");
        }
    }


6.5 富文本编辑器集成
--------------------------------------------------------------------------------
（1）技术难点
    - 如何集成富文本编辑器
    - 如何处理图片上传
    - 如何防止XSS攻击

（2）解决方案
    a. 编辑器选择
       - 使用Vue Quill编辑器
       - 支持文本格式、图片、链接等
       - 提供工具栏配置

    b. 图片上传
       - 配置图片上传处理器
       - 上传到服务器后返回URL
       - 插入到编辑器中

    c. 内容过滤
       - 后端对富文本内容进行过滤
       - 移除危险的HTML标签和属性
       - 只保留安全的标签（p、span、img等）


================================================================================
                        七、性能优化技术
================================================================================

7.1 前端性能优化
--------------------------------------------------------------------------------
（1）防抖和节流
    - 搜索输入框使用防抖，减少API请求
    - 滚动事件使用节流，减少事件处理

    实现：
    import { debounce, throttle } from '@/utils/debounce'

    const handleSearch = debounce((keyword: string) => {
      // 执行搜索
    }, 500)

    const handleScroll = throttle(() => {
      // 处理滚动
    }, 200)

（2）路由懒加载
    - 使用动态import()加载路由组件
    - 减少首屏加载时间

    示例：
    {
      path: '/users',
      component: () => import('@/views/Users.vue')
    }

（3）组件懒加载
    - 使用defineAsyncComponent异步加载组件
    - 只在需要时加载组件

    示例：
    import { defineAsyncComponent } from 'vue'

    const AsyncComponent = defineAsyncComponent(() =>
      import('./components/HeavyComponent.vue')
    )

（4）图片优化
    - 使用适当的图片格式（WebP）
    - 压缩图片大小
    - 使用懒加载（可选）


7.2 后端性能优化
--------------------------------------------------------------------------------
（1）数据库查询优化
    - 使用索引加速查询
    - 避免N+1查询问题
    - 使用分页查询

    示例：
    // 使用@EntityGraph避免N+1问题
    @EntityGraph(attributePaths = {"roles", "roles.permissions"})
    Optional<User> findByUsername(String username);

（2）连接池配置
    - 合理配置连接池大小
    - 设置合适的超时时间
    - 监控连接池使用情况

（3）异步处理
    - 使用@Async注解异步执行耗时操作
    - 使用线程池管理异步任务

    示例：
    @Async
    public void sendEmail(String to, String subject, String content) {
        // 发送邮件逻辑
    }


7.3 数据库性能优化
--------------------------------------------------------------------------------
（1）索引优化
    - 为常用查询字段创建索引
    - 创建复合索引优化多字段查询
    - 避免过多索引影响写入性能

    示例：
    CREATE INDEX idx_username ON users(username);
    CREATE INDEX idx_site_status ON contents(site_id, status);

（2）查询优化
    - 只查询需要的字段
    - 使用LIMIT限制结果数量
    - 避免使用SELECT *

    示例：
    @Query("SELECT new com.cms.module.user.dto.UserDTO(u.id, u.username, u.email) " +
           "FROM User u WHERE u.status = ?1")
    List<UserDTO> findActiveUsers(String status);


================================================================================
                      八、开发工具与环境
================================================================================

8.1 开发工具选择
--------------------------------------------------------------------------------
（1）后端开发工具
    - IDE：IntelliJ IDEA
      优势：强大的Java开发支持、智能代码提示、重构工具

    - 数据库工具：MySQL Workbench / DataGrip
      优势：可视化管理数据库、执行SQL、查看表结构

    - API测试工具：Postman / Swagger UI
      优势：测试API接口、查看API文档

（2）前端开发工具
    - IDE：Visual Studio Code
      优势：轻量级、插件丰富、Vue支持好

    - 浏览器：Chrome + Vue DevTools
      优势：调试Vue应用、查看组件状态、性能分析

（3）版本控制工具
    - Git：版本控制
    - Gitee：代码托管平台
    - SourceTree / GitKraken：Git可视化工具（可选）


8.2 构建工具配置
--------------------------------------------------------------------------------
（1）Maven配置
    - 版本：3.6+
    - 配置文件：pom.xml
    - 常用命令：
      mvn clean compile        # 编译
      mvn spring-boot:run      # 运行
      mvn package              # 打包
      mvn test                 # 测试

（2）Vite配置
    - 版本：5.4.11
    - 配置文件：vite.config.ts
    - 常用命令：
      npm run dev              # 开发模式
      npm run build            # 生产构建
      npm run preview          # 预览构建结果


8.3 开发环境要求
--------------------------------------------------------------------------------
（1）后端环境
    - JDK：11或以上
    - Maven：3.6或以上
    - MySQL：8.0或以上

（2）前端环境
    - Node.js：18或以上
    - npm：9或以上

（3）操作系统
    - Windows 10/11
    - macOS 10.15或以上
    - Linux（Ubuntu 20.04或以上）


8.4 版本控制管理
--------------------------------------------------------------------------------
（1）Git工作流
    - 主分支：main
    - 开发分支：develop
    - 功能分支：feature/功能名称
    - 修复分支：bugfix/问题描述
    - 任务分支：task/任务描述_日期_编号

（2）提交规范
    - feat：新功能
    - fix：修复bug
    - docs：文档更新
    - style：代码格式调整
    - refactor：代码重构
    - test：测试相关
    - chore：构建/工具相关

（3）分支管理
    - 从main分支创建功能分支
    - 开发完成后合并回main分支
    - 定期推送到远程仓库


================================================================================
                        九、技术创新点
================================================================================

9.1 前后端分离架构
--------------------------------------------------------------------------------
本系统采用前后端完全分离的架构，前端和后端通过RESTful API通信。

创新点：
- 前后端独立开发、独立部署
- 前端使用Vue 3最新技术栈
- 后端使用Spring Boot最新稳定版本
- 使用JWT进行无状态认证


9.2 基于角色的权限控制
--------------------------------------------------------------------------------
实现了完整的RBAC权限模型，支持细粒度的权限控制。

创新点：
- 权限细化到具体操作（如user:create、content:view）
- 支持动态权限加载
- 前后端统一的权限控制
- 数据权限和功能权限分离


9.3 可配置工作流引擎
--------------------------------------------------------------------------------
实现了灵活可配置的工作流引擎，支持自定义审批流程。

创新点：
- 使用JSON存储工作流配置
- 支持多级审批
- 支持多人审批
- 自动流程流转


9.4 多站点统一管理
--------------------------------------------------------------------------------
支持在一个系统中管理多个独立站点。

创新点：
- 数据完全隔离
- 统一的管理界面
- 灵活的站点配置
- 独立的分类体系


================================================================================
                            十、附录
================================================================================

10.1 技术参考文档
--------------------------------------------------------------------------------
（1）官方文档
    - Spring Boot：https://spring.io/projects/spring-boot
    - Spring Security：https://spring.io/projects/spring-security
    - Vue 3：https://vuejs.org/
    - Element Plus：https://element-plus.org/
    - MySQL：https://dev.mysql.com/doc/

（2）技术博客
    - Spring Boot中文文档
    - Vue 3中文文档
    - 掘金技术社区
    - CSDN技术博客


10.2 常见问题解答
--------------------------------------------------------------------------------
Q1：为什么选择前后端分离架构？
A1：前后端分离可以提高开发效率，前后端可以并行开发；同时前端可以实现
    更好的用户体验，后端可以专注于业务逻辑。

Q2：为什么选择JWT而不是Session？
A2：JWT是无状态的，服务器不需要存储Session，更适合分布式系统；同时
    JWT可以在不同域之间传递，更适合前后端分离的架构。

Q3：为什么选择MySQL而不是PostgreSQL？
A3：MySQL更加成熟稳定，社区更活跃，文档更丰富，学习成本更低；对于
    本系统的需求，MySQL完全可以满足。

Q4：为什么选择Vue 3而不是React？
A4：Vue 3学习曲线更平缓，文档更完善，中文资料更丰富；同时Vue 3的
    组合式API提供了更好的代码组织方式。

Q5：如何保证系统的安全性？
A5：系统采用了多种安全措施，包括JWT认证、BCrypt密码加密、Spring
    Security权限控制、SQL注入防护、XSS防护等。


10.3 变更记录
--------------------------------------------------------------------------------
版本号    日期          修改人    修改内容
V1.0      2025-10-05    系统      初始版本创建


================================================================================
                            文档结束
================================================================================